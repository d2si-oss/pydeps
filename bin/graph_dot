#! /usr/bin/env python
#
#    Application dependencies management (pydeps)
#
#    Copyright (C) 2017 Cyrielle Camanes (sylicia) <cyrielle.camanes@gmail.com>
#
#    This file is part of pydeps
#
#    This program is free software; you can redistribute it and/or
#    modify it under the terms of the GNU General Public License
#    as published by the Free Software Foundation; either version 2
#    of the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, see <http://www.gnu.org/licenses/>.

"""graph_dot

Usage:
    graph_dot -h | --help
    graph_dot (-t <project> | --target <project>)

Options:
    -h, --help                        Show this screen.
    -t <project>, --target <project>  Project you want to focus on
"""


import logging
import pydeps
import os
from pydeps.exceptions import ArgumentError
from jinja2 import Environment, FileSystemLoader


logger = logging.getLogger(__name__)


#
#   Functions
#
def generate_dot_graph(project):
    """Gerenate a dot graph focused on a specific project.

    The graph will show component of the project and all external
    dependencies.

    :param project: list of configuration path
    :type project: Project
    """
    dot_graph = {
        'clusters': {},
        'nodes': {},
        'links': []
    }
    # create dot cluster for the project
    dot_graph['clusters'][project.name] = get_project_cluster(project)
    external_components = {}
    for appli, appli_info in project.applis.iteritems():
        for compo, compo_info in appli_info.components.iteritems():
            logger.debug(project.name, appli_info.name, compo_info.name)
            links = get_component_links(compo_info)
            dot_graph['clusters'][project.name]['links'] += links['internal']

            dot_graph['links'] += links['external']
            for ext_compo in links['external_components']:
                if ext_compo.appli.project.name not in external_components:
                    external_components[ext_compo.appli.project.name] = []
                external_components[ext_compo.appli.project.name].append(
                                                                    ext_compo
                                                                  )
    # add hidden links from project configuration
    for parent_id, child_id in project.dot['invis_links'].items():
        dot_graph['links'].append({'parent': parent_id,
                                   'child': child_id,
                                   'display': {'style': 'invis'}
                                   })
    # create dot cluster for other projects
    for project_name, compo_list in external_components.items():
        project = pydeps.PROJECTS[project_name]
        dot_graph['clusters'][project_name] = get_project_cluster(
                                                                    project,
                                                                    compo_list
                                                                 )
    logger.debug(dot_graph)
    create_dot_file('./bin/graph_dependencies_detailed.dot.j2', dot_graph)


def create_dot_file(dot_template, dot_variables):
    """ Create dot file from a template

    :param dot_template: Path of the dot template in j2 format
    :param dot_variables: Dot objet definitions
    :type dot_template: str
    :type dot_variables: dict
    """
    dot_file = dot_template.replace('.j2', '')
    with open(dot_file, 'w') as dot:
        dir_name = os.path.dirname(dot_template)
        basename = os.path.basename(dot_template)
        template_loader = FileSystemLoader(searchpath=dir_name)
        template_env = Environment(loader=template_loader)
        dot_content = template_env.get_template(basename).render(dot_variables)
        dot.write(dot_content)
        dot.close()


def get_project_cluster(project, components=()):
    """ Get a dot cluster definition for a project

    It creates the cluster structure with all applications and components by
    default but you can also specify a component in parameters.

    :param Project project: Project to look for
    :param list components: Filter on a list specified components

    :return: Cluster definition
    :rtype: dict

    Format of the cluster returned:
    {
        'clusters': Application as clusters (dict)
        'nodes': Applications as nodes (dict)
        'links': Links between components (list),
        'display': Additional information like colors (dict)
    }
    """
    cluster = {
        'clusters': {},
        'nodes': {},
        'links': [],
        'display': project.dot['custom']
    }
    if len(components) == 0:
        for appli_name, appli in project.applis.iteritems():
            cluster['clusters'][appli.id] = get_appli_cluster(appli)

        for parent_id, child_id in project.dot['invis_links'].iteritems():
            cluster['links'].append({'parent': parent_id,
                                     'child': child_id,
                                     'display': {'style': 'invis'}
                                     })
    else:
        external_components = {}
        for compo in components:
            if compo.appli.name not in external_components.items():
                external_components[compo.appli.name] = []
            external_components[compo.appli.name].append(compo)
        for appli_name, compo_list in external_components.items():
            cluster['clusters'][appli_name] = get_appli_cluster(
                                                project.applis[appli_name],
                                                compo_list
                                            )
    return cluster


def get_appli_cluster(appli, components=()):
    """ Get a dot cluster definition for an application

    It creates the cluster structure with all components by
    default but you can also specify components in parameters.

    :param Application appli: Application to look for
    :param list components: Get only specified :class:`Component` objects

    :return: Cluster definition
    :rtype: dict

    Format of the cluster returned:
    {
        'nodes': Components (dict)
        'label': The application name
        'display': Additional information like colors (dict)
    }
    """
    cluster = {
        'nodes': {},
        'label': appli.name,
        'display': appli.dot['custom']
    }

    if len(components) == 0:
        for compo_name, compo in appli.components.iteritems():
            cluster['nodes'][compo.id] = get_component_node(compo)
    else:
        for compo in components:
            cluster['nodes'][compo.id] = get_component_node(compo)
    return cluster


def get_component_node(component):
    """ Get a dot node definition for a component

    :param component: Component to look for
    :type component: Component

    :return: Cluster definition
    :rtype: dict

    Format of the node returned:
    {
        'id': The uniq indentifier in the graph (str)
        'label': The component name (str)
        'shape': Can be 'ellipse', 'cylinder' or 'tab' ('ellipse' by default)
        'style': 'filled'
    }
    """
    node = {
        'id': component.id,
        'label': component.name,
        'shape': 'ellipse',
        'style': 'filled'
    }
    if component.name in ['DB', 'ES', 'MONGODB']:
        node['shape'] = 'cylinder'
    elif component.name in ['RABBITIN', 'RABBITOUT']:
        node['shape'] = 'tab'
    return node


def get_component_links(compo):
    """Manage the dependencies inside and outside the project
    :param compo: Component to look for
    :type compo: Component

    :return: links definition
    :rtype: dict

    Format of the links returned:
    {
        'internal': Links with components inside the projet (list)
        'external': Links with components outside the projet (list)
        'external_components': Components of other projects that need
                               to be defined (list)
    }

    """
    links = {
        'internal': [],
        'external': [],
        'external_components': []
    }

    for parent in compo.parents:
        if parent.appli.project.name == compo.appli.project.name:
            links['internal'].append({
                'child': compo.id,
                'parent': parent.id,
                'display': compo.appli.dot['custom']
            })
        else:
            links['external'].append({
                'child': parent.id,
                'parent': compo.id,
                'display': compo.appli.dot['custom']
            })
            links['external_components'].append(parent)
    for child in compo.childs:
        if child.appli.project.name != compo.appli.project.name:
            links['external'].append({
                'child': compo.id,
                'parent': child.id,
                'display': child.appli.dot['custom']
            })
            links['external_components'].append(child)
    return links

#
#   Main
#

if __name__ == '__main__':
    # Get target project
    from docopt import docopt

    arguments = docopt(__doc__)
    project_target = arguments['--target']

    # Load projects configuration
    pydeps.load_projects()

    # Check if project exists
    if project_target not in pydeps.PROJECTS:
        raise ArgumentError("Project {0} not found".format(project_target))

    # Display dependencies
    generate_dot_graph(pydeps.PROJECTS[project_target])
