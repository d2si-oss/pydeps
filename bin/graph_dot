#!/usr/bin/env python
"""graph_dot

\033[1mUsage:\033[0m
    graph_dot -h | --help
    graph_dot (-t <project> | --target <project>) [--detailled <value>]

\033[1mOptions:\033[0m
    -h, --help                        Show this screen.
    -t <project>, --target <project>  Project you want to focus on
    --detailled <value>               Generate detailed graph with components
                                         Values: 'yes' or 'no'
                                         [Default: yes]
"""


from pprint import pprint
import types
import logging
import pydeps

# files functions
from os import path, sep
from glob import glob

from pydeps.exceptions import ArgumentError

from jinja2 import Environment, FileSystemLoader

try:
    from yaml import load, CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import load, Loader, Dumper

logger = logging.getLogger(__name__)

#
#   Functions
#
def generate_dot_graph(project):
    """Gerenate a dot graph focused on a specific project.

    The graph will show component of the project and all external
    dependencies.

    :param project: list of configuration path
    :type project: Project
    """
    dot_graph = {
        'clusters': {},
        'nodes': {},
        'links': []
    }
    # create dot cluster for the project
    dot_graph['clusters'][project.name] = get_project_cluster(project)
    external_components = {}
    for appli, appli_info in project.applis.iteritems():
        for compo, compo_info in appli_info.components.iteritems():
            logger.debug(project.name, appli_info.name, compo_info.name)
            links = get_component_links(compo_info)
            dot_graph['clusters'][project.name]['links'] += links['internal']

            dot_graph['links'] += links['external']
            for ext_compo in links['external_components']:
                if ext_compo.appli.project.name not in external_components:
                    external_components[ext_compo.appli.project.name] = []
                external_components[ext_compo.appli.project.name].append(
                                                                    ext_compo
                                                                  )
    # add hidden links from project configuration
    for parent_id, child_id in project.dot['invis_links'].items():
        dot_graph['links'].append({'parent': parent_id,
                                 'child': child_id,
                                 'display': {'style': 'invis'}
                                })
    # create dot cluster for other projects
    for project_name, compo_list in external_components.items():
        project = pydeps.PROJECTS[project_name]
        dot_graph['clusters'][project_name] = get_project_cluster(
                                                                    project,
                                                                    compo_list
                                                                 )
    logger.debug(dot_graph)
    create_dot_file('./bin/graph_dependencies_detailed.dot.j2', dot_graph)


def create_dot_file(dot_template, dot_variables):
    """ Create dot file from a template

    :param dot_template: Path of the dot template in j2 format
    :param dot_variables: Dot objet definitions
    :type dot_template: str
    :type dot_variables: dict
    """
    dot_file = dot_template.replace('.j2', '')
    with open(dot_file, 'w') as dot:
        dirname = path.dirname(dot_template)
        basename = path.basename(dot_template)
        templateLoader = FileSystemLoader(searchpath=dirname)
        templateEnv = Environment(loader=templateLoader)
        dot_content = templateEnv.get_template(basename).render(dot_variables)
        dot.write(dot_content)
        dot.close()


def get_project_cluster(project, components=[]):
    """ Get a dot cluster definition for a project

    It creates the cluster structure with all applications and components by
    default but you can also specify a component in parameters.

    :param project: Project to look for
    :param components: Filter on a list specified components
    :type project: Project
    :type components: list

    :return: Cluster definition
    :rtype: dict

    Format of the cluster returned:
    {
        'clusters': Application as clusters (dict)
        'nodes': Applications as nodes (dict)
        'links': Links between components (list),
        'display': Additional information like colors (dict)
    }
    """
    cluster = {
        'clusters': {},
        'nodes': {},
        'links': [],
        'display': project.dot['custom']
    }
    if len(components) == 0:
        for appli_name, appli in project.applis.iteritems():
            cluster['clusters'][appli.id] = get_appli_cluster(appli)

        for parent_id, child_id in project.dot['invis_links'].iteritems():
            cluster['links'].append({'parent': parent_id,
                                     'child': child_id,
                                     'display': {'style': 'invis'}
                                    })
    else:
        external_components = {}
        for compo in components:
            if compo.appli.name not in external_components.items():
                external_components[compo.appli.name] = []
            external_components[compo.appli.name].append(compo)
        for appli_name, compo_list in external_components.items():
            cluster['clusters'][appli_name] = get_appli_cluster(
                                                project.applis[appli_name],
                                                compo_list
                                            )
    return cluster

def get_appli_cluster(appli, components=[]):
    """ Get a dot cluster definition for an application

    It creates the cluster structure with all components by
    default but you can also specify a component in parameters.

    :param appli: Application to look for
    :param components: Filter on a list specified components
    :type appli: Application
    :type component: Component

    :return: Cluster definition
    :rtype: dict

    Format of the cluster returned:
    {
        'nodes': Components (dict)
        'label': The application name
        'display': Additional information like colors (dict)
    }
    """
    cluster = {
        'nodes': {},
        'label': appli.name,
        'display': appli.dot['custom']
    }

    if len(components) == 0:
        for compo_name, compo in appli.components.iteritems():
            cluster['nodes'][compo.id] = get_component_node(compo)
    else:
        for compo in components:
            cluster['nodes'][compo.id] = get_component_node(compo)
    return cluster


def get_component_node(component):
    """ Get a dot node definition for a component

    :param component: Component to look for
    :type component: Component

    :return: Cluster definition
    :rtype: dict

    Format of the node returned:
    {
        'id': The uniq indentifier in the graph (str)
        'label': The component name (str)
        'shape': Can be 'ellipse', 'cylinder' or 'tab' ('ellipse' by default)
        'style': 'filled'
    }
    """
    node = {
        'id': component.id,
        'label': component.name,
        'shape': 'ellipse',
        'style': 'filled'
    }
    if component.name in ['DB', 'ES', 'MONGODB']:
        node['shape'] = 'cylinder'
    elif component.name in ['RABBITIN', 'RABBITOUT']:
        node['shape'] = 'tab'
    return node


def get_component_links(compo):
    """Manage the dependencies inside and outside the project
    :param compo: Component to look for
    :type compo: Component

    :return: links definition
    :rtype: dict

    Format of the links returned:
    {
        'internal': Links with components inside the projet (list)
        'external': Links with components outside the projet (list)
        'external_components': Components of other projects that need
                               to be defined (list)
    }

    """
    links = {
        'internal': [],
        'external': [],
        'external_components': []
    }

    for parent in compo.parents:
        if parent.appli.project.name == compo.appli.project.name:
            links['internal'].append({
                'child': compo.id,
                'parent': parent.id,
                'display': compo.appli.dot['custom']
            })
        else:
            links['external'].append({
                'child': parent.id,
                'parent': compo.id,
                'display': compo.appli.dot['custom']
            })
            links['external_components'].append(parent)
    for child in compo.childs:
        if child.appli.project.name != compo.appli.project.name:
            links['external'].append({
                'child': compo.id,
                'parent': child.id,
                'display': child.appli.dot['custom']
            })
            links['external_components'].append(child)
    return links

#
#   Main
#

if __name__ == '__main__':
    # Get target project
    from docopt import docopt

    arguments = docopt(__doc__)
    project_target = arguments['--target']

    if arguments['--detailled'] == 'yes':
        is_detailled = True
    elif arguments['--detailled'] == 'no':
        is_detailled = False
    else:
        raise ArgumentError('Only "yes" or "no" supported for --macro')

    # Load projects configuration
    pydeps.load_projects()

    # Check if project exists
    if project_target not in pydeps.PROJECTS:
        raise ArgumentError("Project {0} not found".format(project_target))

    # Display dependencies
    generate_dot_graph(pydeps.PROJECTS[project_target])
